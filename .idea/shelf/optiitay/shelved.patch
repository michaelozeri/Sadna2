Index: EM-MMM.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import json\r\nfrom numpy import log, sum, amax, exp, shape\r\nfrom scipy.special import logsumexp\r\nimport numpy as np\r\nimport time\r\nimport logging\r\nimport sys\r\nimport Utils\r\n\r\n# we don't want to update signatures array (itay asked) at this point so i made\r\n# a global to set if to update the signatures data or not at this time\r\nLOG_INITIAL_PI_KEY = \"log_initial_pi\"\r\nLOG_SIGNATURES_DATA_KEY = \"log_signatures_data\"\r\nA_ARRAY_KEY = \"a_array\"\r\nDIM_N_KEY = \"dim_n\"\r\nE_ARRAY_KEY = \"e_array\"\r\nLOG_B_ARRAY_KEY = \"b_array\"\r\nDIM_M_KEY = \"dim_m\"\r\nDIM_T_KEY = \"dim_t\"\r\nUPDATE_SIGNATURES_DATA = False\r\n\r\n######### CROSS VALIDATION FIELDS #######\r\n\r\nthreshold = 0.01\r\nmax_iteration = 1000\r\n\r\n######### LOGGER CONFIG #######\r\n\r\nlogging.basicConfig(filename='./Results/algorithm_1-' + sys.argv[1] + '_results.log', level=logging.DEBUG,\r\n                    format='%(name)s - %(levelname)s - %(message)s')\r\nlogger = logging.getLogger(\"logger_for_algo_1_\" + sys.argv[1])\r\n\r\n\r\n############################################## MMM FUNCTIONS ##############################################\r\n\r\n\r\ndef convert_to_log_scale(initial_pi):\r\n    return np.array(log(initial_pi))\r\n\r\n\r\ndef convert_to_log_scale_eij(signatures_data):\r\n    return np.array(log(signatures_data))\r\n\r\n\r\ndef initialize_chromosome_mmm_parameters(input_x, mmm_person_params):\r\n    dim_m = mmm_person_params[DIM_M_KEY]\r\n    dim_n = mmm_person_params[DIM_N_KEY]\r\n    dim_t = len(input_x)\r\n    log_b_array = np.log(create_b_array(input_x, dim_m))\r\n    # are calculated each iteration\r\n    e_array = np.zeros((dim_n, dim_m))\r\n    a_array = np.zeros(dim_n)\r\n    log_signatures_data_copy = mmm_person_params[LOG_SIGNATURES_DATA_KEY].copy()\r\n    log_initial_pi_copy = mmm_person_params[LOG_INITIAL_PI_KEY].copy()\r\n    return {DIM_T_KEY: dim_t, LOG_B_ARRAY_KEY: log_b_array, E_ARRAY_KEY: e_array, A_ARRAY_KEY: a_array,\r\n            LOG_SIGNATURES_DATA_KEY: log_signatures_data_copy, LOG_INITIAL_PI_KEY: log_initial_pi_copy,\r\n            DIM_N_KEY: dim_n, DIM_M_KEY: dim_m}\r\n\r\n\r\ndef assign_person_params(initial_pi, signatures_data):\r\n    # defining the mmm\r\n    log_signatures_data = convert_to_log_scale_eij(signatures_data)\r\n    log_initial_pi = convert_to_log_scale(initial_pi)\r\n    # constants - don't change\r\n    dim_n = len(log_signatures_data)\r\n    dim_m = len(log_signatures_data[0])\r\n    return {DIM_M_KEY: dim_m, DIM_N_KEY: dim_n,\r\n            LOG_INITIAL_PI_KEY: log_initial_pi, LOG_SIGNATURES_DATA_KEY: log_signatures_data}\r\n\r\n\r\n# on input data (sequence or sequences) do EM iterations until the model improvement is less\r\n# than  threshold , or until max_iterations iterations.\r\ndef fit(input_x_data, total_mmm_parameters):\r\n    current_number_of_iterations = 1\r\n    old_score = likelihood(input_x_data, total_mmm_parameters)\r\n    e_step(total_mmm_parameters)\r\n    m_step(total_mmm_parameters)\r\n    new_score = likelihood(input_x_data, total_mmm_parameters)\r\n    while (abs(new_score - old_score) > threshold) and (current_number_of_iterations < max_iteration):\r\n        # print(\"delta is: \" + abs(new_score - old_score).__str__())\r\n        old_score = new_score\r\n        e_step(total_mmm_parameters)\r\n        # print(self.log_initial_pi)\r\n        m_step(total_mmm_parameters)\r\n        # print(self.log_initial_pi)\r\n        new_score = likelihood(input_x_data, total_mmm_parameters)\r\n        current_number_of_iterations += 1\r\n        # print(\"number of iterations is: \" + number_of_iterations.__str__())\r\n    return\r\n\r\n\r\ndef e_step(mmm_parameters):\r\n    dim_n = mmm_parameters[DIM_N_KEY]\r\n    dim_m = mmm_parameters[DIM_M_KEY]\r\n    # this is the correct calc for the Eij by the PDF\r\n    k_array = [logsumexp((mmm_parameters[LOG_INITIAL_PI_KEY] + mmm_parameters[LOG_SIGNATURES_DATA_KEY][:, j])) for j in\r\n               range(dim_m)]\r\n    mmm_parameters[E_ARRAY_KEY] = [(mmm_parameters[LOG_B_ARRAY_KEY] + mmm_parameters[LOG_INITIAL_PI_KEY][i] +\r\n                                    mmm_parameters[LOG_SIGNATURES_DATA_KEY][i] - k_array) for i in range(dim_n)]\r\n    # this is from the mail with itay to calculate log(Ai)\r\n    mmm_parameters[A_ARRAY_KEY] = logsumexp(mmm_parameters[E_ARRAY_KEY], axis=1)\r\n\r\n\r\n# checks convergence from formula\r\n# on input on input data (sequence or sequences), return log probability to see it\r\ndef likelihood(input_x_data, mmm_parameters):\r\n    convergence = 0\r\n    for t in range(mmm_parameters[DIM_T_KEY]):\r\n        temp_log_sum_array = mmm_parameters[LOG_INITIAL_PI_KEY] + mmm_parameters[LOG_SIGNATURES_DATA_KEY][:,\r\n                                                                  int(input_x_data[t])]\r\n        convergence += logsumexp(temp_log_sum_array)\r\n    return convergence\r\n\r\n\r\ndef m_step(mmm_parameters):\r\n    mmm_parameters[LOG_INITIAL_PI_KEY] = mmm_parameters[A_ARRAY_KEY] - log(mmm_parameters[DIM_T_KEY])\r\n    if UPDATE_SIGNATURES_DATA:\r\n        for i in range(mmm_parameters[DIM_N_KEY]):\r\n            for j in range(mmm_parameters[DIM_M_KEY]):\r\n                # numerically stable for pi - Eij is already log(Eij)\r\n                mmm_parameters[LOG_SIGNATURES_DATA_KEY][i][j] = mmm_parameters[E_ARRAY_KEY][i][j] - log(\r\n                    sum(log_to_regular(mmm_parameters[E_ARRAY_KEY]), axis=1)[j])\r\n\r\n\r\ndef create_b_array(input_x, m):\r\n    b = np.zeros(m)\r\n    for i in range(len(input_x)):\r\n        b[int(input_x[i] - 1)] += 1\r\n    return np.array(b)\r\n\r\n\r\ndef log_to_regular(param):\r\n    return exp(param)\r\n\r\n\r\n############################################## CROSS VALIDATION FUNCTIONS ##############################################\r\n\r\n\r\ndef compute_likelihood_for_chromosome(ignored_chromosome, person, mmm_person_params, input_x_total):\r\n    mmm_chromosome_params = initialize_chromosome_mmm_parameters(input_x_total, mmm_person_params)\r\n    fit(input_x_total, mmm_chromosome_params)\r\n    ignored_sequence = person[ignored_chromosome][\"Sequence\"]\r\n    mmm_chromosome_params[DIM_T_KEY] = len(ignored_sequence)\r\n    return likelihood(ignored_sequence, mmm_chromosome_params)\r\n\r\n\r\ndef person_cross_validation(person, mmm_person_params):\r\n    total_sum_person = 0\r\n    input_x_total = np.array([])\r\n    # train\r\n    for chromosome in person:\r\n        chromosome_sequence = np.array(person[chromosome][\"Sequence\"])\r\n        input_x_total = np.append(input_x_total, chromosome_sequence)\r\n    temp_location_sum = 0\r\n    for ignored_chromosome in person:\r\n        start_remove_index = temp_location_sum\r\n        end_remove_index = temp_location_sum + len(person[ignored_chromosome][\"Sequence\"])\r\n        input_x_after_remove = np.delete(input_x_total, np.s_[start_remove_index:end_remove_index])\r\n        likelihood_for_ignored_chromosome = compute_likelihood_for_chromosome(ignored_chromosome, person,\r\n                                                                              mmm_person_params, input_x_after_remove)\r\n        temp_location_sum = end_remove_index\r\n        logger.debug(\"likelihood_for_ignored_chromosome: \" + ignored_chromosome + \" in log space is :\" + str(\r\n            likelihood_for_ignored_chromosome))\r\n        logger.debug(\"likelihood_for_ignored_chromosome: \" + ignored_chromosome + \" in regular space is :\" + str(\r\n            np.exp(likelihood_for_ignored_chromosome)))\r\n        total_sum_person += likelihood_for_ignored_chromosome\r\n    return total_sum_person\r\n\r\n\r\ndef compute_cross_validation_for_total_training_data(dict_data, initial_pi, signatures_data):\r\n    total_sum = 0\r\n    person_number = 1\r\n    mmm_person_params = assign_person_params(initial_pi, signatures_data)\r\n    for person in dict_data:\r\n        start = time.time()\r\n        person_cross_validation_result = person_cross_validation(dict_data[person], mmm_person_params)\r\n        logger.debug(\"person_cross_validation_result for person: \" + str(person_number) + \" in log space is: \" + str(\r\n            person_cross_validation_result))\r\n        logger.debug(\r\n            \"person_cross_validation_result for person: \" + str(person_number) + \" in regular space is: \" + str(\r\n                np.exp(person_cross_validation_result)))\r\n        total_sum += person_cross_validation_result\r\n        end = time.time()\r\n        logger.debug(\r\n            \"Execution time for person \" + str(person_number) + \" is: \" + str(end - start) + \" Seconds, \" + str(\r\n                (end - start) / 60) + \" Minutes.\")\r\n        person_number += 1\r\n    return total_sum\r\n\r\n\r\n############################################## START RUN OF FILE ##############################################\r\n\r\n\r\ndef test_MMM_algo():\r\n    # read example data from JSON\r\n    with open('data/example.json') as f:\r\n        data = json.load(f)\r\n    initial_pi = (data['initial_pi'])\r\n    trained_pi = data['trained_pi']\r\n    input_x = data['input']\r\n\r\n    # read dictionary data from JSON\r\n    # each key is a persons data - and inside there is chromosomes 1-22,X.Y and their input x1,...xt\r\n    with open('data/ICGC-BRCA.json') as f1:\r\n        dic_data = json.load(f1)\r\n\r\n    # read signatures array from BRCA-signatures.npy\r\n    # this is an array of 12x96 - [i,j] is e_ij - fixed in this case until we change\r\n    signatures_data = np.load(\"data/BRCA-signatures.npy\")\r\n\r\n    print(\"started the init\")\r\n    person_params = assign_person_params(initial_pi, signatures_data)\r\n    mmm_parameters = initialize_chromosome_mmm_parameters(input_x, person_params)\r\n\r\n    fit(input_x, mmm_parameters)\r\n\r\n    err = 0\r\n    for i in range(len(initial_pi)):\r\n        err += abs(log_to_regular(mmm_parameters[LOG_INITIAL_PI_KEY][i]) - trained_pi[i])\r\n        # print(abs(mmm.log_to_regular(mmm.log_initial_pi[i]) - trained_pi[i]))\r\n\r\n    print(err)\r\n    # print(mmm.likelihood(dic_data))\r\n\r\n\r\ndef main_algorithm_1_1():\r\n    # read dictionary data from JSON\r\n    # each key is a persons data - and inside there is chromosomes 1-22,X.Y and their input x1,...xt\r\n    with open('data/ICGC-BRCA.json') as f1:\r\n        dic_data = json.load(f1)\r\n    with open('data/example.json') as f:\r\n        data = json.load(f)\r\n    initial_pi = np.array(data['initial_pi'])\r\n    # read signatures array from BRCA-signatures.npy\r\n    # this is an array of 12x96 - [i,j] is e_ij - fixed in this case until we change\r\n    signatures_data = np.array(np.load(\"data/BRCA-signatures.npy\"))\r\n    logger.debug(\"Started cross validation for 1'st type algorithm\")\r\n    print(\"Started cross validation for 1'st type algorithm\")\r\n    training = compute_cross_validation_for_total_training_data(dic_data, initial_pi, signatures_data)\r\n    logger.debug(\"Total sum is: \" + str(training))\r\n\r\n\r\ndef main_algorithm_1_2():\r\n    # read dictionary data from JSON\r\n    # each key is a persons data - and inside there is chromosomes 1-22,X.Y and their input x1,...xt\r\n    with open('data/BRCA-strand-info.json') as f1:\r\n        dic_data = json.load(f1)\r\n    dic_finals = Utils.split_dictionary_to_strands(dic_data)\r\n    with open('data/example.json') as f:\r\n        data = json.load(f)\r\n    initial_pi = np.array(data['initial_pi'])\r\n    # read signatures array from BRCA-signatures.npy\r\n    # this is an array of 12x96 - [i,j] is e_ij - fixed in this case until we change\r\n    signatures_data = np.array(np.load(\"data/BRCA-signatures.npy\"))\r\n    logger.debug(\"Started cross validation for 1'st algorithm type 2\")\r\n    logger.debug(\"########################## started PLUS strand for algorithm 1-2 ##################################\")\r\n    training = compute_cross_validation_for_total_training_data(dic_finals[\"strand_dict_plus\"], initial_pi,\r\n                                                                signatures_data)\r\n    logger.debug(\"Total training sum is: \" + str(training))\r\n    logger.debug(\r\n        \"########################## started MINUS strand for algorithm 1-2 ##################################\")\r\n    training = compute_cross_validation_for_total_training_data(dic_finals[\"strand_dict_minus\"], initial_pi,\r\n                                                                signatures_data)\r\n    logger.debug(\"Total training sum is: \" + str(training))\r\n\r\n\r\ndef main():\r\n    if sys.argv[1] == \"test\":\r\n        test_MMM_algo()\r\n    elif sys.argv[1] == \"1\":\r\n        print(\"starting run of main 1-1\")\r\n        main_algorithm_1_1()\r\n    else:\r\n        print(\"starting run of main 1-2\")\r\n        main_algorithm_1_2()\r\n\r\n\r\n# function call\r\nmain()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- EM-MMM.py	(revision fce37ebb00e0365cc1a8d6522a97751627fb9e90)
+++ EM-MMM.py	(date 1557763803038)
@@ -46,7 +46,7 @@
     dim_m = mmm_person_params[DIM_M_KEY]
     dim_n = mmm_person_params[DIM_N_KEY]
     dim_t = len(input_x)
-    log_b_array = np.log(create_b_array(input_x, dim_m))
+    log_b_array = create_b_array(input_x, dim_m)
     # are calculated each iteration
     e_array = np.zeros((dim_n, dim_m))
     a_array = np.zeros(dim_n)
@@ -72,10 +72,10 @@
 # than  threshold , or until max_iterations iterations.
 def fit(input_x_data, total_mmm_parameters):
     current_number_of_iterations = 1
-    old_score = likelihood(input_x_data, total_mmm_parameters)
+    old_score = likelihood(total_mmm_parameters)
     e_step(total_mmm_parameters)
     m_step(total_mmm_parameters)
-    new_score = likelihood(input_x_data, total_mmm_parameters)
+    new_score = likelihood(total_mmm_parameters)
     while (abs(new_score - old_score) > threshold) and (current_number_of_iterations < max_iteration):
         # print("delta is: " + abs(new_score - old_score).__str__())
         old_score = new_score
@@ -83,7 +83,7 @@
         # print(self.log_initial_pi)
         m_step(total_mmm_parameters)
         # print(self.log_initial_pi)
-        new_score = likelihood(input_x_data, total_mmm_parameters)
+        new_score = likelihood(total_mmm_parameters)
         current_number_of_iterations += 1
         # print("number of iterations is: " + number_of_iterations.__str__())
     return
@@ -95,7 +95,7 @@
     # this is the correct calc for the Eij by the PDF
     k_array = [logsumexp((mmm_parameters[LOG_INITIAL_PI_KEY] + mmm_parameters[LOG_SIGNATURES_DATA_KEY][:, j])) for j in
                range(dim_m)]
-    mmm_parameters[E_ARRAY_KEY] = [(mmm_parameters[LOG_B_ARRAY_KEY] + mmm_parameters[LOG_INITIAL_PI_KEY][i] +
+    mmm_parameters[E_ARRAY_KEY] = [(np.log(mmm_parameters[LOG_B_ARRAY_KEY]) + mmm_parameters[LOG_INITIAL_PI_KEY][i] +
                                     mmm_parameters[LOG_SIGNATURES_DATA_KEY][i] - k_array) for i in range(dim_n)]
     # this is from the mail with itay to calculate log(Ai)
     mmm_parameters[A_ARRAY_KEY] = logsumexp(mmm_parameters[E_ARRAY_KEY], axis=1)
@@ -103,12 +103,11 @@
 
 # checks convergence from formula
 # on input on input data (sequence or sequences), return log probability to see it
-def likelihood(input_x_data, mmm_parameters):
+def likelihood(mmm_parameters):
     convergence = 0
-    for t in range(mmm_parameters[DIM_T_KEY]):
-        temp_log_sum_array = mmm_parameters[LOG_INITIAL_PI_KEY] + mmm_parameters[LOG_SIGNATURES_DATA_KEY][:,
-                                                                  int(input_x_data[t])]
-        convergence += logsumexp(temp_log_sum_array)
+    for j in range(96):
+        convergence += ((mmm_parameters[LOG_B_ARRAY_KEY][j]) * (
+            logsumexp(mmm_parameters[LOG_INITIAL_PI_KEY] + mmm_parameters[LOG_SIGNATURES_DATA_KEY][:, j])))
     return convergence
 
 
@@ -141,7 +140,7 @@
     fit(input_x_total, mmm_chromosome_params)
     ignored_sequence = person[ignored_chromosome]["Sequence"]
     mmm_chromosome_params[DIM_T_KEY] = len(ignored_sequence)
-    return likelihood(ignored_sequence, mmm_chromosome_params)
+    return likelihood(mmm_chromosome_params)
 
 
 def person_cross_validation(person, mmm_person_params):
